---
title: 深入Python——查漏补缺(三)
date: 2019-10-30 16:33:09
categories: Python工程
tags: Python廖雪峰、Python查漏补缺
mathjax: true
---

* Python内置了一套异常处理机制，来帮助我们进行错误处理。此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。<!--more-->
* Python内置的logging模块可以非常容易地记录错误信息，同样是出错，但程序打印完错误信息后会继续执行，并正常退出。通过配置，logging还可以把错误记录到日志文件里，方便事后排查。
* 捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型。只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。
* 程序中如果到处充斥着assert，和print()相比也好不到哪去，不过，启动Python解释器时可以用-O参数来关闭assert。关闭后，可以把所有的assert语句当成pass来看。logging.info()就可以输出一段文本，允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。
* 启动Python的调试器pdb，单步执行，或者pdb.set_trace()，虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。
* 测试用例放到一个测试模块里，就是一个完整的单元测试。以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
* 文档测试，doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。
* 由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。同步和异步的区别就在于是否等待IO执行的结果。异步(回调--好了叫我，轮询---好了没...好了没)
* 像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。StringIO就是在内存中创建的file-like Object，常用作临时缓冲。在Python中，文件读写是通过open()函数打开的文件对象完成的。使用with语句操作文件IO是个好习惯。
* StringIO，在内存中读写str，getvalue()方法用于获得写入后的str，BytesIO实现了在内存中读写bytes。
* 操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中。把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符；同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名；os.path.splitext()可以直接让你得到文件扩展名；shutil模块提供了copyfile()的函数。
* 变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization ，marshalling，flattening等等。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。Python提供了pickle模块来实现序列化。Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python 彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。
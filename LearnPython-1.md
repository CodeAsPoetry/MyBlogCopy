---
title: 深入Python——查漏补缺(一)
date: 2019-10-26 13:09:40
categories: Python工程
tags: Python廖雪峰、Python查漏补缺
mathjax: true
---

* Python 中 dict ：key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。dict的key必须是不可变对象。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。<!--more-->在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key
* set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。
* 对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
* 函数的参数：位置参数、默认参数、可变参数、关键字参数、命名关键字参数。参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。
* 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。
* Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断

* ```python
  from collections import Iterable
  isinstance('abc', Iterable)
  
  # 对list实现类似Java那样的下标循环，Python内置的`enumerate`函数可以把一个list变成索引-元素对
  for i, value in enumerate(['A', 'B', 'C']):
      print(i, value)
  ```

* 列表生成式

  ```python
  [x * x for x in range(1, 11) if x % 2 == 0]
  ```

* 在Python中，一边循环一边计算的机制，称为生成器：generator。创建一个generator，第一种方法很简单，只要把一个列表生成式的[ ]改成( )，就创建了一个generator，然后，使用for循环获得生成器的每个元素。定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator 和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator 的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代，但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration 的value中

* 可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。Python的for循环本质上就是通过不断调用next()函数实现的。

* 函数本身也可以赋值给变量，即：变量可以指向函数；函数名其实就是指向函数的变量；既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数，函数式编程就是指这种高度抽象的编程范式。

* Python内建了map( )和reduce( )函数。map( )函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

* filter( )接收一个函数和一个序列。filter( )把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。filter( )的作用是从一个序列中筛出符合条件的元素。由于filter( )使用了惰性计算，所以只有在取filter( )结果的时候，才会真正筛选并每次返回下一个筛出的元素。

* sorted( )函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。要进行反向排序，不必改动key函数，可以传入第三个参数reverse = True

* 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum 返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。

* 在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。匿名函数 lambda x: x * x，关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

* 在代码运行期间动态增加功能的方式，称之为“装饰器”(Decorator) 。本质上，decorator就是一个返回函数的高阶函数，借助Python的@语法，把decorator置于函数的定义处。如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。Python内置的functools.wraps就是干这个事的。

* 偏函数，functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数。当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。

* 当试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。要添加自己的搜索目录，有两种方法：一是直接修改sys.path，添加要搜索的目录，这种方法是在运行时修改，运行结束后失效；第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。





















